/** * A class of bags whose entries are stored in a chain of linked nodes. The bag * is never full. *  * @author Frank M. Carrano * @author Timothy M. Henry * @version 4.0 */public final class EntryWayList<T extends Comparable> implements EntryWayListInterface<T> {	private Node firstNode; // Reference to first node	private Node lastNode;	private int numberOfEntries;	private int spaceNumber = 10; 	public EntryWayList() {		firstNode = null;		lastNode = null;		numberOfEntries = 0;	} // end default constructor	public boolean insertHead(T newEntry) {		// Add to beginning of chain:		Node newNode = new Node(newEntry, null, null);		newNode.next = firstNode; // Make new node reference rest of chain									// (firstNode is null if chain is empty)		if(numberOfEntries >0) {			firstNode.previous = newNode;		}		if (numberOfEntries == 0){ // empty list, adding the 1st element			lastNode = firstNode;		}		firstNode = newNode; // New node is at beginning of chain		numberOfEntries++;		return true;	}	public T deleteHead(){		T result = null;		if (firstNode != null) { // non empty list 			result = firstNode.data;			Node detachedNode = firstNode;			firstNode = firstNode.next;			detachedNode.next = null;			if (firstNode !=null){				firstNode.previous = null;			}						//firstNode = firstNode.next; // Remove first node from chain			numberOfEntries--;			if(numberOfEntries <2) {				lastNode = firstNode;			}		} // end if		return result;	}	public boolean insertTail(T newEntry){		Node newNode = new Node(newEntry);		if (lastNode !=null){			lastNode.next = newNode;		  newNode.previous = lastNode;		  lastNode =lastNode.next;		} else {			lastNode = newNode;			firstNode = newNode;		}						if (numberOfEntries == 0){ // empty list, adding the 1st element			firstNode = lastNode;		} 		numberOfEntries++;		return true;	}	public T deleteTail(){		T result = null;		if (lastNode != null) { // if the list is non-empty			result = lastNode.data;			if (numberOfEntries ==1){ // only 1 element case, need to remove the last element				lastNode = lastNode.previous;			} else {				Node toBeRemoved = lastNode;				lastNode = lastNode.previous;				if(toBeRemoved !=null){					toBeRemoved.previous = null;				}				lastNode.next = null;			}						numberOfEntries--;		} // end if		return result;	}	public void display(){		Node currentNode = firstNode;		String result = "";		while (currentNode!= null){			result += currentNode.data+ " -> ";			currentNode = currentNode.next;		}		System.out.println(result);	}	public int contains(T anEntry){		Node currentNode = firstNode;		int index = 1;				while (currentNode!= null){			if (anEntry.equals(currentNode.data)){				return index;			}			currentNode = currentNode.next;			index++;		}		return -1;			}	public boolean isEmpty(){		return numberOfEntries == 0;	}	public boolean isFull(){		return numberOfEntries == spaceNumber;	}	private class Node {		private T data; // Entry in bag		private Node next; // Link to next node		private Node previous; // link to previous node		private Node(T dataPortion) {			this(dataPortion, null, null);		} // end constructor		private Node(T dataPortion, Node nextNode, Node previousNode) {			data = dataPortion;			next = nextNode;			previous = previousNode;		} // end constructor	} // end Node} // end LinkedBag